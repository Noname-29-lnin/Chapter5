\question{Câu 3}

Cho đoạn code C sau dùng để sắp xếp một mảng n phần tử theo thứ tự tăng dần sử dụng giải thuật \textbf{\textit{Selection Sort}}:

\begin{minipage}{.5\linewidth}
	\begin{lstlisting}[style=StyleCode, language=C, caption={Đoạn chương trình C của giải thuật Selection Sort.}, label=lis: selectionsort_debai, basicstyle=\fontsize{9}{10}\selectfont\ttfamily]
		int n = arr.size() - 1;
		for(int i = 0; i < n; i++) {
			min = i;
			for(int j = i+1; j <= n; j++){
				if(arr[j] < arr[min]){
					min = j;
				}
			}
			swap(arr[i], arr[min]);
		}
	\end{lstlisting}
\end{minipage}
%\hspace{0.1cm}
\begin{minipage}{.5\linewidth}
	\begin{figure}[H]
		\centering
		\includegraphics[width=.7\linewidth]{my-chapters/my-images/Question3/req_ram.png}
		\caption{Yêu cầu của bộ nhớ.}
		\label{fig:reqram}
	\end{figure}
\end{minipage}

Người ta muốn chuyển đổi giải thuật ở đoạn code \ref{lis: selectionsort_debai} trên sang phần cứng để thực thi. Giả sử mảng được lưu trong bộ nhớ \textit{Single Port} ở hình \ref{fig:reqram} và quá trình đọc/ghi diễn ra đồng bộ theo Clock và hoàn thành trong 1 Clock.

\answer{a}{Định nghĩa ngõ vào ra của thiết kế, vẽ kết nối của thiết kế của bộ nhớ (Yêu cầu phải có chân Start và Reset).}

Ta tiến hành biểu diễn đoạn code \ref{lis: selectionsort_debai} trên dưới dạng flowchart như sau:

\begin{figure}[H]
	\centering
	\includegraphics[width=.7\linewidth]{./my-chapters/my-diagrams/quesion3/Flowchart.png}
	\caption{Flowchart của thuật toán Selection Sort.}
	\label{fig: flowchart_selectionSort}
\end{figure}

Từ hình \ref{fig: flowchart_selectionSort}, cho ta thấy được các dữ liệu được đọc trước và các dữ liệu có sẵn để có thể dễ dàng trong việc chuyển đổi từ giải thuật phần mềm qua phần cứng. Thực hiện kiểm chứng cách hoạt động của giải thuật theo flowchart và giải thuật góc ở chương trình \ref{lis: selectionsort_debai}.

\begin{minipage}{.4\linewidth}
	\begin{lstlisting}[style=StyleCode, language=Cpp, caption={Đoạn code nguyên mẫu của giải thuật Selection Sort.}]
		void selection_sort_standard(std::vector<int> &arr){
			int n = arr.size() - 1;
			for(int i = 0; i < n; i++){
				int min = i;
				for(int j = i+1; j <= n; j++){
					if(arr[j] < arr[min]){
						min = j;
					}
				}
				std::swap(arr[i], arr[min]);
			}
		}
		
		
		
		
		
		
		
		
		
		
		
	\end{lstlisting}
\end{minipage}
\hspace{1cm}
\begin{minipage}{.4\linewidth}
	\begin{lstlisting}[style=StyleCode, language=Cpp, caption={Đoạn code chỉnh sửa của giải thuật Selection Sort.}]
		void selection_sort_cus(std::vector<int> &arr){
			int n = arr.size() - 1;
			int min         = 0;
			int temp_data   = 0;
			int temp_min    = 0;
			int data_key    = 0;
			int data_min    = 0;
			for(int i = 0; i < n; i++){
				data_key = arr[i];
				min = i;
				for(int j = i + 1; j <= n; j++){
					temp_data = arr[j];
					temp_min  = arr[min];
					if(temp_data < temp_min){
						min = j;
					}
					data_min = arr[min];
				}
				arr[i] = data_min;
				arr[min] = data_key;
			}
		}
	\end{lstlisting}
\end{minipage}

Kết quả cho ra là:

\begin{lstlisting}[style=StyleResult, language=Result, caption={Kết quả so sánh 2 cách viết của Selection Sort.}]
	Finished reading file: ./tools/unsorted.txt
	Check Selection_Sort Standard: PASS
	Finish write file './Reports/COMPILE_REPORT/sorted_standard.txt'.
	Check Selection_Sort Cus: PASS
	Finish write file './Reports/COMPILE_REPORT/sorted_cus.txt'.
\end{lstlisting}

Sau khi đã viết lại đoạn code cho dễ nhìn, tiếp đến sẽ định nghĩa lại ngõ vào vầ ra của module top chính ra \texttt{Selection\_Sort} như sau:

 \begin{table}[H]
	 \centering
	 \begin{tabular}{|>{\centering\arraybackslash}m{3cm}
	 				 |>{\centering\arraybackslash}m{2cm}
			       	 |>{\centering\arraybackslash}m{2cm}
			         |>{\raggedright\arraybackslash}m{8cm}|}
		     \hline
		     Signal & I/O & Size & Functional \\
		     \hline
		     i\_clk & Input &1 & Clock của toàn hệ thống. \\
		     \hline
		     i\_rst\_t & Input & 1 & Tín hiệu reset của hệ thống với tích cực thấp. \\
		     \hline
		     i\_start & Input & 1 & Tín hiệu bắt đầu hoạt động của bộ. \\
		     \hline 
		     o\_done & Output & 1 & Tín hiệu cho biết được đã sắp xếp xong mảng.\\
		     \hline
	\end{tabular}
	\caption{Bảng I/O của module \texttt{Selection\_Sort}.}
\end{table}

Từ đó, ta có thiết kế tổng quan của module \texttt{Selection\_Sort}:

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\linewidth]{./my-chapters/my-diagrams/quesion3/Design_Overview.png}
	\caption{Thiết kế tổng quan của module \texttt{Selection\_Sort}.}
\end{figure}

\answer{b}{Thiết kế máy trạng thái bậc cao của thiết kế.}

\begin{figure}[H]
	\centering
	\includegraphics[width=.9\linewidth]{./my-chapters/my-diagrams/quesion3/fsm.png}
	\caption{Lưu đồ trạng thái của module \texttt{Selection\_Sort}.}
\end{figure}

FSM gồm có 16 trạng thái như sau:

\begin{itemize}[label=-]
	\item \textsf{IDLE:} là trạng thái khởi tạo của module sau khi có reset, và chờ có tín hiệu \texttt{i\_start} để module bắt đầu hoạt động.
	\item \textsf{START:} là trạng thái khởi tạo giá trị khởi tạo cho \texttt{value\_i}.
	\item \textsf{READ\_DATA\_KEY:} là đợi đọc dữ liệu tại vị trí đang xét (theo giá trị \texttt{value\_i}).
	\item \textsf{COMPARE\_I:} là trạng thái kiểm tra vòng lặp (for) cho biến \texttt{value\_i} xem đã kết thúc quá trình sắp xếp dữ liệu trong mảng.
	\item \textsf{READ\_TEMP\_MIN:} là trạng thái đọc dữ liệu \texttt{temp\_min} có mục đích để kiểm tra ra giá trị nhỏ nhất từ vị trí \texttt{value\_i} đến cuối mảng.
	\item \textsf{COMPARE\_J:} là trạng thái kiểm tra vòng lặp (for) cho biến \texttt{value\_j} xem đã kết thúc quá trình dò giá trị trong mảng.
	\item \textsf{READ\_TEMP\_DATA:} là trạng thái đọc dữ liệu theo giá trị của \texttt{value\_j}.
	\item \textsf{COMPARE\_TEMP\_VALUE:} là kiểm tra thử xem có giá trị nào nhỏ hơn tại vị trí tại giá trị nhỏ nhất hiện tại.
	\item \textsf{UPDATE\_MIN\_VALUE:} là việc cập nhật vị trí cho vị trí min của dữ liệu.
	\item \textsf{UPDATE\_J:} là trạng thái thực hiện việc tăng giá trị của \texttt{value\_j}.
	\item \textsf{WAIT\_UPDATE\_J:} là trạng thái chờ giá trị \texttt{value\_j} cập nhật.
	\item \textsf{WRITE\_TEMP\_MIN:} thực hiện ghi lại dữ liệu nhỏ nhất lại vị trí đang xét tại \texttt{value\_i}.
	\item \textsf{WRITE\_WAIT:} là trạng thái chờ dữ liệu ghi.
	\item \textsf{WRITE\_DATA\_KEY:} thực hiện ghi lại giá trị ở tại \texttt{value\_i} vào thế chỗ của \texttt{value\_min}.
	\item \textsf{UPDATE\_I:} là trạng thái thực hiện việc tăng giá trị của \texttt{value\_i}.
	\item \textsf{WAIT\_UPDATE\_I:} là trạng thái chờ cập nhật cho giá trị \texttt{value\_i}.
\end{itemize}

\answer{c}{Thiết kế Datapath và Control Unit của thiết kế.}

\begin{enumerate}[label=\arabic*.]
	\item Thiết kế DataPath:
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=.9\linewidth]{./my-chapters/my-diagrams/quesion3/DataPath.png}
		\caption{Thiết kế tổng quan của module \texttt{DataPath\_Unit}.}
	\end{figure}
	
	\begin{itemize}[label=-]
		\item \textsf{RAM\_Addr:}
			\begin{figure}[H]
				\centering
				\includegraphics[width=.5\linewidth]{./my-chapters/my-diagrams/quesion3/Block_Addr.png}
			\end{figure}
		\item \textsf{RAM\_Read\_data:}
			\begin{figure}[H]
				\centering
				\includegraphics[width=.5\linewidth]{./my-chapters/my-diagrams/quesion3/Block_Read.png}
			\end{figure}
		\item \textsf{RAM\_Write\_data:}
			\begin{figure}[H]
				\centering
				\includegraphics[width=.5\linewidth]{./my-chapters/my-diagrams/quesion3/Block_Write.png}
			\end{figure}
	\end{itemize}
	
	\item Thiết kế của Control\_Unit:
		\begin{figure}[H]
			\centering
			\includegraphics[width=.7\linewidth]{./my-chapters/my-diagrams/quesion3/Control_Unit.png}
		\end{figure}
\end{enumerate}

\answer{d}{Viết chương trình mô phỏng hoạt động của thiết kế.}

\begin{enumerate}[label=\arabic*.]
	\item Thiết kế tổng quan:
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Selection\_Sort}}.]{./../Quesion_3/02_rtl/Selection_Sort.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{SinglePort\_RAM}}.]{./../Quesion_3/02_rtl/SinglePort_RAM.sv}
		
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Control\_unit}}.]{./../Quesion_3/02_rtl/Control_unit.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Data\_path}}.]{./../Quesion_3/02_rtl/Data_path.sv}
		
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Block\_Addr}}.]{./../Quesion_3/02_rtl/Block_Addr.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Block\_Read\_data}}.]{./../Quesion_3/02_rtl/Block_Read_data.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Block\_Write\_data}}.]{./../Quesion_3/02_rtl/Block_Write_data.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{RAM\_addr}}.]{./../Quesion_3/02_rtl/RAM_addr.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{RAM\_read\_data}}.]{./../Quesion_3/02_rtl/RAM_read_data.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{RAM\_write\_data}}.]{./../Quesion_3/02_rtl/RAM_write_data.sv}
		
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{SS\_detect\_edge}}.]{./../Quesion_3/02_rtl/SS_detect_edge.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Update\_I}}.]{./../Quesion_3/02_rtl/Update_I.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Update\_J}}.]{./../Quesion_3/02_rtl/Update_J.sv}
		\lstinputlisting[style=StyleCode, language=SystemVerilog, caption={Module \texttt{Update\_MIN}}.]{./../Quesion_3/02_rtl/Update_MIN.sv}		
	\item Kiểm định lại hoạt động của module:
	
	\begin{lstlisting}[style=StyleResult, language=Result, caption={Kết quả sau khi kiểm định lại chức năng của module.}]
			Building instance specific data structures.
		Loading native compiled code:     .................... Done
		Design hierarchy summary:
		Instances  Unique
		Modules:                16      15
		Registers:             116     113
		Scalar wires:           92       -
		Vectored wires:         55       -
		Always blocks:          29      27
		Initial blocks:          3       3
		Cont. assignments:      24      24
		Pseudo assignments:     75      75
		Simulation timescale:  1ps
		Writing initial simulation snapshot: worklib.tb_Selection_Sort:sv
		Loading snapshot worklib.tb_Selection_Sort:sv .................... Done
		xmsim: *W,DSEM2009: This SystemVerilog design is simulated as per IEEE 1800-2009 SystemVerilog simulation semantics. Use -disable_sem2009 option for turning off SV 2009 simulation semantics.
		xcelium> source /opt/cadence/XCELIUM2009/tools/xcelium/files/xmsimrc
		xcelium> run
		>>> Sending START...
		>>> DONE received at time 23305000
		
		===== RAM AFTER SORT =====
		RAM[0] = 0b
		RAM[1] = 14
		RAM[2] = 28
		RAM[3] = 3d
		RAM[4] = 65
		RAM[5] = 6e
		RAM[6] = 80
		RAM[7] = 90
		RAM[8] = 95
		RAM[9] = 98
		RAM[10] = bd
		RAM[11] = bf
		RAM[12] = c4
		RAM[13] = c5
		RAM[14] = e2
		RAM[15] = f2
		>>> Saved sorted RAM to sorted_output.txt
		Simulation complete via $finish(1) at time 23325 NS + 0
		../Topmodule/tb_Selection_Sort.sv:71         $finish;
		xcelium> exit
		TOOL:	xrun(64)	20.09-s001: Exiting on Dec 12, 2025 at 08:31:02 EST  (total: 00:00:01)
	\end{lstlisting}
\end{enumerate}

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\linewidth]{./my-chapters/my-diagrams/quesion3/waveform_test.png}
	\caption{Sóng ngõ ra tổng quan của module test.}
\end{figure}

\answer{e}{Giả sử vòng lặp $i = 0$, không có swap (hoán đổi) và vòng lặp $i = 1$, có swap. Vẽ dạng sóng từ 
	lúc $start = 1$ đển lúc hoàn thành vòng lặp $i = 1$ của thiết kế.}

\begin{enumerate}[label=\arabic*.]
	\item Vòng lặp $i = 0$ với không có swap:
		\begin{figure}[H]
			\centering
			\includegraphics[width=\linewidth]{./my-chapters/my-diagrams/quesion3/noswap.png}
		\end{figure}
	\item Vòng lặp $i = 0$ với có swap:
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{./my-chapters/my-diagrams/quesion3/swap.png}
	\end{figure}
\end{enumerate}
